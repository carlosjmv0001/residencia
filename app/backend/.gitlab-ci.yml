variables:
  DOCKER_DRIVER: overlay2
  # Cache configuration
  npm_config_cache: '$CI_PROJECT_DIR/.npm'
  HARBOR_PROJECT: 'gsc-residencia-devops'
  # Kubernetes configuration
  HELM_RELEASE_NAME: residencia-app-backend
  HELM_CHART_PATH: gsc-nucleo-java/residencia-devsecops/residencia-app/infra/backend
  NAMESPACE: gsc-residencia-devops-dev

# Template reutilizável para regras
.default_rules: &default_rules
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "main"

# Cache global para node_modules
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .npm/
    - node_modules/

stages:
  - setup
  - quality
  - test
  - build
  - push
  - deploy

install_dependencies:
  image: node:18.20.4-bookworm
  stage: setup
  script:
    - npm install --legacy-peer-deps
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull-push

lint:
  image: node:18.20.4-bookworm
  stage: quality
  script:
    - npm run lint
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull
  <<: *default_rules

test:
  image: node:18.20.4-bookworm
  stage: test
  script:
    - npm run test:coverage -- --ci --reporters=default --reporters=jest-junit
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    when: always
    reports:
      junit: test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull
  <<: *default_rules

build:
  image: node:18.20.4-bookworm
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - build/
    expire_in: 1 week
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
    policy: pull
  <<: *default_rules

push_to_registry:
  stage: push
  image: docker:25-cli
  services:
    - docker:25-dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "$HARBOR_PASSWORD" | docker login $HARBOR_REGISTRY -u "$HARBOR_USERNAME" --password-stdin
  script:
    - docker build --cache-from $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:latest
      -t $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:$CI_COMMIT_SHORT_SHA
      -t $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:latest .
    - docker push $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:$CI_COMMIT_SHORT_SHA
    - docker push $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:latest
  after_script:
    - docker logout $HARBOR_REGISTRY
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "main"

deploy:
  stage: deploy
  variables:
    HARBOR_PROJECT: 'gsc-residencia-devops'
    IMAGE_TAG: $HARBOR_REGISTRY/$HARBOR_PROJECT/backend-app:$CI_COMMIT_SHORT_SHA
  trigger:
    project: gsc-nucleo-java/residencia-devsecops/residencia-app/infra/backend
    branch: $CI_COMMIT_REF_NAME
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "main"

#deploy:
#  stage: deploy
#  script:
#    # Criar o secret baseado nas variáveis do GitLab CI
#    - |
#      cat <<EOF | kubectl apply -f -
#      apiVersion: v1
#      kind: Secret
#      metadata:
#        name: app-secrets
#      type: Opaque
#      stringData:
#        DATABASE_URL: "${DATABASE_URL}"
#        JWT_SECRET: "${JWT_SECRET}"
#      EOF
#
#    # Aplicar o deployment
#    - envsubst < deployment.yaml | kubectl apply -f -
#  environment:
#    name: production

#.deploy_template: &deploy_template
#  image:
#    name: alpine/helm:3.12.0
#    entrypoint: [""]
#  before_script:
#    # Instalar kubectl
#    - apk add --no-cache curl
#    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
#    - chmod +x kubectl
#    - mv kubectl /usr/local/bin/
#    # Configurar acesso ao cluster
#    - echo "${KUBECONFIG_FILE}" | base64 -d > ${CI_PROJECT_DIR}/kubeconfig
#    - export KUBECONFIG=${CI_PROJECT_DIR}/kubeconfig
#    # Adicionar repositórios Helm se necessário
#    - helm repo add bitnami https://charts.bitnami.com/bitnami
#    - helm repo update
#  script:
#    # Verificar se o namespace existe, se não, criar
#    - kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
#    # Deploy usando Helm
#    - >
#      helm upgrade --install ${HELM_RELEASE_NAME} ${HELM_CHART_PATH}
#      --namespace ${NAMESPACE}
#      --set image.repository=${HARBOR_REGISTRY}/your-username/your-image-name
#      --set image.tag=${CI_COMMIT_SHA}
#      --set environment=${CI_ENVIRONMENT_NAME}
#      --atomic
#      --timeout 5m
#      --values ${HELM_CHART_PATH}/values-${CI_ENVIRONMENT_NAME}.yaml
#  after_script:
#    # Limpar kubeconfig
#    - rm -f ${CI_PROJECT_DIR}/kubeconfig
#
#deploy_to_staging:
#  <<: *deploy_template
#  stage: deploy
#  environment:
#    name: staging
#    url: https://staging.your-domain.com
#  rules:
#    - if: $CI_COMMIT_BRANCH == "dev"
#
#deploy_to_production:
#  <<: *deploy_template
#  stage: deploy
#  environment:
#    name: production
#    url: https://your-domain.com
#  rules:
#    - if: $CI_COMMIT_BRANCH == "main"
#  when: manual